"""
Неожиданно на Покровке в корпусе Z рядом с теннисными столами решили поставить стол для аэрохоккея!
Конечно же, в самый ближайший перерыв к нему выстроилась огромная очередь из n человек. Чтобы как можно больше
людей успели поиграть, было решено действовать следующим образом: сначала партию играют первые двое людей из очереди.
Затем проигравший становится в конец очереди, а победитель играет со следующим человеком из очереди.
Для большего азарта (и экономии времени) все это дело продолжается до тех пор, пока кто-то из
игроков не победит суммарно k раз. Пусть для каждого из участников такого турнира вы знаете его силу
игры в аэрохоккей (чем выше, тем лучше человек играет). Причем в партии побеждает игрок с наибольшей такой силой.
Определите, кто же будет победителем!

Формат ввода
Сначала вводятся два числа: n и k (2 ≤ n ≤ 500, 2 ≤ k ≤ 10^12).

В следующей строке содержится n целых чисел p1, p2, …, pn (1 ≤ pi ≤ n). Каждое число – это сила i-го игрока.
Причем ситуация сложилась так, что все pi различны.

Формат вывода
Требуется вывести силу победившего игрока.

Примечания
Птички напели, что отличным вариантом будет использовать структуру данных deque из модуля collections.
Подробнее тут: https://docs.python.org/3/library/collections.html

Кроме того, помните, что Python умеет выполнять всего лишь около 10^6 операций в секунду,
поэтому симулировать все партии, пока не наберется k побед, может быть вообще не ок, и вы получите TL.
Подумайте, в какой момент можно точно остановить цикл.

Не забывайте, что массив можно ввести вот так: a = list(map(int, input().split()))
"""

from collections import deque

n, k = list(map(int, input().split()))

queue = deque(map(int, input().split()))
max_skill = max(queue)
players = [queue.popleft(), queue.popleft()]

max_wins = 0
wins = {}

while max_wins < k:
    loser = players.pop(players.index(min(players)))
    winner = players[0]
    if winner not in wins:
        wins[winner] = 0
    wins[winner] += 1

    if wins[winner] >= max_wins:
        max_wins = wins[winner]

    if winner == max_skill:
        break
    else:
        queue.append(loser)
        players.append(queue.popleft())

print(winner)
